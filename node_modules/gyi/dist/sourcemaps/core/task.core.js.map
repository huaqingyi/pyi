{"version":3,"sources":["core/task.core.ts"],"names":[],"mappings":"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","file":"../../core/task.core.js","sourcesContent":["import { GYI } from \"./gyi\";\nimport Undertaker from 'undertaker';\nimport { map, find } from 'lodash';\nimport gulp, { series as seriesFun, parallel as parallelFun, watch } from 'gulp';\nimport * as libs from '../libs';\nimport { LibsBase } from \"../libs\";\n\nexport interface TaskOption {\n    src?: string;\n    dest?: string;\n    series?: Undertaker.Task[];\n    parallel?: Undertaker.Task[];\n    injectable?: { [x: string]: any };\n}\n\nexport interface TaskConfig {\n    option?: TaskOption;\n    inject?: string[];\n}\n\nexport class TaskCore extends GYI {\n\n    protected libs!: LibsBase[];\n\n    constructor() {\n        super();\n        this.libs = map(libs, lib => <any>lib);\n    }\n\n    async injectTask(name: string, key: string, option: TaskConfig) {\n        if (!this.store[name]) this.store[name] = [];\n        this.store[name].push({ key, option });\n    }\n\n    async makeTask(mode: Function) {\n        const { name } = mode;\n        const instance = new (mode as any);\n\n        await Promise.all(map(this.store[name], async config => {\n            const { key, option } = config;\n            let exec = (async () => {\n                let end: NodeJS.ReadWriteStream;\n                let destEnd: NodeJS.ReadWriteStream | null = null;\n                if (option.option) {\n                    const { src, dest } = option.option;\n                    if (src) end = await gulp.src(src);\n                    if (dest) destEnd = gulp.dest(dest);\n                }\n                let inject: any[] = [];\n                if (option.inject && option.inject.length > 0) {\n                    inject = map(option.inject, lib => {\n                        let LibInstance: any = find(this.libs, item => (item as any).name === lib.name);\n                        if (LibInstance.name === 'Gulp') return gulp;\n                        if (!LibInstance) {\n                            if (option.option && option.option.injectable) {\n                                const { injectable } = option.option;\n                                if (injectable && injectable[lib.name]) return new injectable[lib.name](end);\n                                return injectable;\n                            }\n                            return undefined;\n                        }\n                        return new LibInstance(end);\n                    });\n                }\n                end = await instance[key].apply(instance, inject);\n                if (end && destEnd !== null) end = await end.pipe(destEnd);\n            }).bind(this);\n\n            if (!option.option) return await gulp.task(key, exec);\n\n            const { series, parallel } = option.option;\n\n            if (series) {\n                return await gulp.task(key, seriesFun(...series.concat([exec])));\n            } else if (parallel) {\n                return await gulp.task(key, parallelFun(...parallel.concat([exec])));\n            } else if (series && parallel) {\n                return new Error(`series not have parallel ...`);\n            }\n            return await gulp.task(key, exec);\n        }));\n    }\n}"]}