{"version":3,"sources":["decorators/execption.ts"],"names":[],"mappings":";;AAAA,iCAA+B;AAC/B,mCAAoC;AAEpC,SAAgB,YAAY,CACxB,SAA+B,EAAE,EAAmB;IAEpD,OAAO,CAAC,GAAoB,EAAE,EAAE;QAC5B,IACI,GAAG,IAAI,GAAG,CAAC,QAAQ;YACnB,mBAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,QAAQ,EAAE,KAAK,YAAK,EACtD;YAAE,EAAE,GAAG,GAAG,CAAC;SAAE;QACf,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACrB,MAAM,UAAU,GAAG,IAAI,SAAS,EAAE,CAAC;QACnC,MAAM,EAAE,GAAiB,UAAU,CAAC,MAAM,EAAE,CAAC;QAC7C,IAAI,EAAE,EAAE;YACJ,OAAO,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;gBACpB,OAAO,IAAI,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC;gBAC/B,uBAAuB;YAC3B,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;gBACb,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC;gBACrC,OAAO,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;gBACxD,gDAAgD;YACpD,CAAC,CAAC,CAAC;SACN;aAAM;YACH,OAAO,EAAE,CAAC;SACb;IACL,CAAC,CAAC;AACN,CAAC;AAxBD,oCAwBC;AAQD,SAAgB,MAAM,CAAC,MAAW,EAAE,GAAW;IAC3C,MAAM,EAAE,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IACjE,MAAM,KAAK,GAAG,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IAChD,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,KAAK,WAAU,GAAG,KAAU;QAC5D,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;QACnD,IAAI,mBAAU,CAAC,SAAS,CAAC,EAAE;YACvB,OAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC5C;QACD,OAAO,MAAM,SAAS,CAAC;IAC3B,CAAC,CAAC;IACF,OAAO,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AAC7C,CAAC;AAXD,wBAWC","file":"../../decorators/execption.js","sourcesContent":["import { PYIVo } from './impl';\nimport { isFunction } from 'lodash';\n\nexport function PYIExecption<UseParentClass = any, UsePYIVo = PYIVo>(this: any,\n    execption: UseParentClass & any, Vo?: UsePYIVo & any\n): any {\n    return (NVo?: UsePYIVo & any) => {\n        if (\n            NVo && NVo._extends &&\n            isFunction(NVo._extends) && NVo._extends() === PYIVo\n        ) { Vo = NVo; }\n        execption.bind(this);\n        const exinstance = new execption();\n        const ex: Promise<any> = exinstance.throws();\n        if (Vo) {\n            return ex.then((resp) => {\n                return this.ctx = new Vo(resp);\n                // return new Vo(resp);\n            }).catch((err) => {\n                const { errno, errmsg } = exinstance;\n                return this.ctx = (new Vo()).throws(err, errno, errmsg);\n                // return (new Vo()).throws(err, errno, errmsg);\n            });\n        } else {\n            return ex;\n        }\n    };\n}\n\nexport interface PYIThrows {\n    errno?: number;\n    errmsg?: string;\n    throws: (...args: any) => Promise<any>;\n}\n\nexport function throws(target: any, key: string): any {\n    const Vo = Reflect.getMetadata('design:returntype', target, key);\n    const merge = target.constructor.prototype[key];\n    target.constructor.prototype[key] = async function(...props: any) {\n        const execption = await merge.bind(this)(...props);\n        if (isFunction(execption)) {\n            return await execption.apply(this, [Vo]);\n        }\n        return await execption;\n    };\n    return target.constructor.prototype[key];\n}\n"]}